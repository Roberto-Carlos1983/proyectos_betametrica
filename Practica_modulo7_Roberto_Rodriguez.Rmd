---
title: "Pratica_modulo7_Roberto_Rodriguez"
author: "Roberto_Rodriguez"
date: "`r Sys.Date()`"
output: github_document
---

```{r libreries, include=FALSE}
library(readxl)
library(dplyr)
library(urca)
library(forecast)
library(uroot)
library(ggplot2)
```

# SECCION A

## Seleccion de variable

Se seleccionaran los datos de ingresos mensuales de remesas familiares en El Salvador, informacion expresada en millones de dolares americanos. Asimismo, se realizara la transformacion de la base de datos en una serie de tiempo.


Los datos comienzan en enero de 2010 y terminan en septiembre de 2023, totalizando 165 observaciones.

```{r carga_base, echo=FALSE}
base <- read_xlsx("D:\\Ciencia de datos\\Modulo 7\\Ingresos_mensuales_de_remesas_familiares.xlsx",
                  sheet = "Sheet1")

basets <- ts(as.vector(as.matrix(base)),
             start = c(2010,1),
             frequency = 12)

str(basets)
```

## Graficos

```{r graph1, echo=FALSE}
ts.plot(basets)
```

En el grafico de la serie se puede observar que existe una tendencia creciente en la serie, excepto en el año 2020 donde como resultado de la pandemia, se tiene una caida significativa. En este mismo grafico resalta el componente estacional ya que a finales de cada año hay un incremento de remesas, lo que puede estar relacionado a que las familias salvadoreñas reciben una mayor cantidad de recursos a fin de año por las fiestas navideñas.


Tambien hay un par de picos en algunos meses de cada año, que con este grafico no es observable con facilidad. Por ello, a continuacion se muestran tres graficos adicionales que permiten ver de mejor forma el comportamiento estacional.

```{r graph2, echo=FALSE}
dects <- decompose(basets)
plot(dects)

monthplot(basets)

ggseasonplot(basets, year.labels = TRUE) +
  ggtitle("Componente estacional: Remesas (En millones de $)")
```

Para detectar con mayor claridad el componente estacional, se descompuso la serie y tambien se presentan dos graficos adicionales donde se puede observar que en diciembre hay una marcado incremento en las remesas. En marzo y en mayo se tienen ciertos picos (principalmente mayo), que podrian estar relacionados a: 1) marzo, semana santa, que en El Salvador es feriado nacional por una semana; sin embargo, este pico no es tan significativo, debido a que la semana santa no siempre cae en marzo; y 2) mayo, ya que existe una gran celebracion por el Dia de la Madre.

## Test de raiz unitaria

```{r test_adf, echo=FALSE}
adftest <- ur.df(basets, type = c("trend"),
                 selectlags = c("BIC"))
summary(adftest)
```

La hipotesis son:


Ho: serie no estacionaria


H1: serie estacionaria


Debido a que el valor del test es mayor al valor critico, se rechaza la hipotesis nula, por lo que indicaria que la serie es estacionaria.

```{r test_pp, echo=FALSE}
pptest <- ur.pp(basets, type = c("Z-tau"), model = c("trend"),
                lags = c("short"))

summary(pptest)
```

La hipotesis son:


Ho: serie no estacionaria


H1: serie estacionaria


Debido a que el valor del test es mayor al valor critico, se rechaza la hipotesis nula, por lo que indicaria que la serie es estacionaria.

```{r test_kpss, echo=FALSE}
kpsstest <- ur.kpss(basets, type = c("tau"), lags = c("short"))

summary(kpsstest)
```

La hipotesis son:


Ho: estacionariedad


H1: no estacionariedad


En este caso, se rechaza la hipotesis nula, porque con un nivel de confianza del 95%, el valor calculado es mayor que el critico. Serie no estacionaria

```{r test_ers, echo=FALSE}
erstest <- ur.ers(basets, type = c("DF-GLS"), model = c("trend"),
                  lag.max = 4)

summary(erstest)
```

La hipotesis son:


Ho: serie no estacionaria


H1: serie estacionaria


En este caso, no se rechaza la hipotesis nula, porque con un nivel de confianza del 95%, el valor calculado es menor que el critico. Serie no estacionaria.


En resumen, se tiene dos test que indican que la serie es estacionaria y dos indican lo contrario. En este caso, debido a que claramente se puede observar una tendencia en la serie, si bien la varianza puede ser la misma en ciertos tramos, la media claramente va cambiando. En este sentido, se tomara la serie como no estacionaria y se la diferenciara una vez y volveran a aplicar los contrastes.

```{r test_serie_diferencia, echo=FALSE}
adftest1 <- ur.df(diff(basets,1), type = c("none"),
                 selectlags = c("BIC"))
summary(adftest1)

pptest1 <- ur.pp(diff(basets,1), type = c("Z-tau"),
                lags = c("short"))
summary(pptest1)

kpsstest1 <- ur.kpss(diff(basets,1), type = c("tau"), lags = c("short"))
summary(kpsstest1)

erstest1 <- ur.ers(diff(basets,1), type = c("DF-GLS"),
                  lag.max = 4)
summary(erstest1)

```


La serie en primera diferencia es estacionaria con los 4 contrastes. Ahora, se verificara cuantas veces se debe diferenciar la serie para que sea estacionaria y ademas se verificara si la serie en su componente estacional debe diferenciarse para ser estacionaria.

```{r test_estacionariedad_estacional}
ndiffs(basets, test = "adf")
ndiffs(basets, test = "pp")
ndiffs(basets, test = "kpss")

nsdiffs(basets, test=c("ocsb"))
nsdiffs(basets, test=c("ch"))
```

Con los resultados anteriores, se confirma que la serie debe diferenciarse una vez para ser estacionaria. Ademas, se concluye que la serie no debe diferenciarse en su componente estacional.


En conclusion, se trabajara con la primera diferencia para observar las funciones de autocorrelacion simple y parcial y asi determinar el mejor modelo.

# SECCION B

## Correlogramas

```{r correlogramas, fig.width=12}
par(mfrow=c(1,2))
Acf(diff(basets,1))
Pacf(diff(basets,1))
```

Se comenzo la prueba con un proceso ARIMA(1,1,1)(1,0,0) y posteriormente se fue verificando la significancia de coeficientes, tambien si se tiene correlacion en los residuos y si los correlogramas de los residuos se encuentran dentro de las bandas.


En definitiva, se encontro que una buena opcion de modelamiento es con un modelo ARIMA(4,1,1)(1,0,2), sin considerar el AR(3). 

```{r best_model, fig.width=12}
model1 <- Arima(basets,
                order = c(4,1,1),
                seasonal=list(order=c(1,0,2)),
                fixed=c(NA,NA,0,NA,NA,NA,NA,NA),
                method = "ML")

model1

as.matrix(subset(model1$coef,abs(model1$coef)>0))/as.matrix(diag(model1$var.coef))

accuracy(model1)

par(mfrow=c(1,1))
plot(model1$residuals)

Box.test(model1$residuals,
         type=c("Ljung-Box"),
         lag = 5)


par(mfrow=c(1,2))
Acf(model1$residuals)
Pacf(model1$residuals)
```

De acuerdo al primer grafico, los residuos muestran un comportamiento aleatorio. El Box-Ljung test indica que los errores no estan correlacionados y el correlograma de los residuos muestran los datos basicamente dentro de las bandas.

## Pronostico

```{r pronostico_best, fig.width=12}
f1 <- forecast(model1, h=4)
f1

par(mfrow=c(1,1))
cols1 <- c("blue","red","green")
ts.plot(basets, f1$fitted,
        f1$mean,col=cols1)
legend("topleft", c("original",
                    "ajustado","proyectado"), 
       cex=1.2,fill=cols1)
```

El pronostico mantiene el comportamiento estacional, proyectando un importante incremento en diciembre como era esperado.


## AUTOARIMA

```{r autoarima, fig.width=12}
model2 <- auto.arima(basets)
model2

as.matrix(subset(model2$coef,abs(model2$coef)>0))/as.matrix(diag(model2$var.coef))

accuracy(model2)

par(mfrow=c(1,1))
plot(model2$residuals)

Box.test(model2$residuals,
         type=c("Ljung-Box"),
         lag = 1)

par(mfrow=c(1,2))
Acf(model2$residuals)
Pacf(model2$residuals)


f2 <- forecast(model2, h=4)
f2
```

El modelo generado automaticamente cumple con los requisitos para realizar las proyecciones, ya que sus erores describen un comportamiento aleatorio, no estan correlacionados y los autocorrelogramas de los residuos estan basicamente dentro de las bandas.

## Grafico conjunto de ARIMA modelado y AUTO ARIMA

```{r resultados_finales, fig.width=12}
cols2 <- c("black","blue","orange")
ts.plot(basets, f1$fitted, f2$fitted, col=cols2)
legend("topleft", c("original","ajustados_mod_final","ajustados_automatico"),
       cex=1.2,fill=cols2)
```


Si bien se tienen dos modelos totalmente distintos, los resultados en terminos de ajuste del modelo y sus proyecciones son similares. 